const express = require('express');
const mysql = require('mysql2/promise');
const path = require('path');
const multer = require('multer');
const cors = require('cors');
const fs = require('fs');
const dotenv = require('dotenv');  
const axios = require('axios');
dotenv.config();  // ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡πà‡∏≤ .env
console.log(process.env.DB_HOST);  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å .env


const app = express();
app.use(express.json());
app.use(cors());


const pool = mysql.createPool({
  host: process.env.DB_HOST,  // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å .env
  user: process.env.DB_USER,  // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å .env
  password: process.env.DB_PASSWORD,  // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å .env
  database: process.env.DB_NAME,  // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å .env
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

// -------------------- Routes --------------------

// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
app.get('/', (req, res) => {
  res.send('üöÄ Moom Aroi Backend is running!');
});

// Guy edit
// Multer configuration for menu images
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  },
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const filetypes = /jpeg|jpg|png/;
    const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = filetypes.test(file.mimetype);
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Only JPEG, JPG, and PNG files are allowed'));
    }
  },
}).single('image');

app.use('/uploads', express.static('uploads'));

// Multer error handling
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    return res.status(400).json({ error: err.message });
  } else if (err) {
    return res.status(400).json({ error: err.message });
  }
  next();
});
// ------------------------------------------------------------‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ-------------------------------------------
// GET /api/menu - Fetch menu items with optional category filter
app.get('/api/menu', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    console.log('[%s] Connecting to MySQL...', new Date().toISOString());
    console.log('[%s] Connected to MySQL', new Date().toISOString());

    const { category } = req.query;
    console.log('[%s] Received category:', new Date().toISOString(), category);

    let query = 'SELECT * FROM menu';
    let queryParams = [];

    if (category) {
      query += ' WHERE category = ?';
      queryParams.push(category);
    }

    console.log('[%s] Executing query: %s with params: %s', new Date().toISOString(), query, queryParams);
    const [rows] = await connection.query(query, queryParams);
    console.log('[%s] Select query executed successfully, rows: %d', new Date().toISOString(), rows.length);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° base URL ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö image
    const baseUrl = `${req.protocol}://${req.get('host')}`;
    const updatedRows = rows.map(item => ({
      ...item,
      image: item.image ? `${baseUrl}${item.image}` : ''
    }));

    connection.release();
    console.log('[%s] MySQL connection released', new Date().toISOString());

    res.json(updatedRows);
  } catch (err) {
    console.error('[%s] Error in GET /api/menu:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/menu/:id', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    const { id } = req.params;
    const [rows] = await connection.query('SELECT * FROM menu WHERE id = ?', [id]);
    connection.release();
    if (rows.length === 0) return res.status(404).json({ error: 'Menu item not found' });
    const baseUrl = `${req.protocol}://${req.get('host')}`;
    const item = {
      ...rows[0],
      image: rows[0].image ? `${baseUrl}${rows[0].image}` : ''
    };
    res.json(item);
  } catch (err) {
    console.error('Error in GET /api/menu/:id:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ------------------------------------------------------------------ Admin Edit Menu --------------------------------------------------------------------
// POST /api/menu - Add new menu item ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ó‡∏≥‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á tags
app.post('/api/admin/menu', (req, res) => {
  upload(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ error: err.message });
    }

    console.log('[%s] req.body:', new Date().toISOString(), req.body);
    console.log('[%s] req.file:', new Date().toISOString(), req.file);

    const { category, name_tha, name_eng, short_description, full_description, price_starts_at, tags } = req.body;
    const image = req.file ? `/uploads/${req.file.filename}` : null;

    if (!category || !name_eng || !short_description || !full_description || !price_starts_at || !tags || !image) {
      console.log('[%s] Missing fields - category:', category, 'name_eng:', name_eng, 'short_description:', short_description, 'full_description:', full_description, 'price_starts_at:', price_starts_at, 'tags:', tags, 'image:', image);
      return res.status(400).json({ error: 'Missing required fields: category, name_eng, short_description, full_description, price_starts_at, tags, and image are required' });
    }

    const priceNum = parseFloat(price_starts_at);
    if (isNaN(priceNum) || priceNum <= 0) {
      return res.status(400).json({ error: 'Price must be a valid positive number' });
    }

    try {
      const connection = await pool.getConnection();
      console.log('[%s] Connecting to MySQL...', new Date().toISOString());
      console.log('[%s] Connected to MySQL', new Date().toISOString());

      console.log('[%s] Executing query: INSERT INTO menu', new Date().toISOString());
      const [result] = await connection.query(
        'INSERT INTO menu (category, name_tha, name_eng, short_description, full_description, price_starts_at, tags, image) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [category, name_tha || null, name_eng, short_description, full_description, priceNum, tags, image]
      );
      console.log('[%s] Insert query executed successfully, inserted ID: %d', new Date().toISOString(), result.insertId);

      console.log('[%s] Executing query: SELECT * FROM menu WHERE id = %d', new Date().toISOString(), result.insertId);
      const [rows] = await connection.query('SELECT * FROM menu WHERE id = ?', [result.insertId]);
      console.log('[%s] Select query executed successfully', new Date().toISOString());

      connection.release();
      console.log('[%s] MySQL connection released', new Date().toISOString());

      res.status(201).json(rows[0]);
    } catch (err) {
      console.error('[%s] Error in POST /api/menu:', new Date().toISOString(), err);
      res.status(500).json({ error: err.message || 'Internal server error' });
    }
  });
});

// DELETE /api/admin/menu/:id - Delete a menu item by ID
app.delete('/api/admin/menu/:id', async (req, res) => {
  const menuId = req.params.id;

  try {
    const connection = await pool.getConnection();
    console.log('[%s] Connecting to MySQL...', new Date().toISOString());

    // 1. ‡∏´‡∏≤ path ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û
    const [rows] = await connection.query('SELECT image FROM menu WHERE id = ?', [menuId]);
    if (rows.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'Menu item not found' });
    }

    const imagePath = rows[0].image;
    console.log('[%s] Image path:', new Date().toISOString(), imagePath);

    // 2. ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const [result] = await connection.query('DELETE FROM menu WHERE id = ?', [menuId]);
    connection.release();

    // 3. ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    if (imagePath) {
      const fullImagePath = path.join(__dirname, 'uploads', path.basename(imagePath));
    
      if (fs.existsSync(fullImagePath)) {
        fs.unlinkSync(fullImagePath);
        console.log('[%s] Image file deleted: %s', new Date().toISOString(), fullImagePath);
      } else {
        console.warn('[%s] Image file not found: %s', new Date().toISOString(), fullImagePath);
      }
    }
    
    res.json({ message: `Menu item with ID ${menuId} deleted successfully` });
  } catch (err) {
    console.error('[%s] Error in DELETE /api/admin/menu/:id:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// PATCH /api/admin/menu/:id - Update a menu item
app.patch('/api/admin/menu/:id', (req, res) => {
  upload(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ error: err.message });
    }

    const menuId = req.params.id;
    const { category, name_tha, name_eng, short_description, full_description, price_starts_at, tags } = req.body;
    const newImage = req.file ? `/uploads/${req.file.filename}` : null;

    try {
      const connection = await pool.getConnection();
      console.log('[%s] Connecting to MySQL...', new Date().toISOString());

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏ô‡∏π‡πÄ‡∏î‡∏¥‡∏°
      const [existingRows] = await connection.query('SELECT * FROM menu WHERE id = ?', [menuId]);
      if (existingRows.length === 0) {
        connection.release();
        return res.status(404).json({ error: 'Menu item not found' });
      }

      const existingMenu = existingRows[0];

      // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÉ‡∏´‡∏°‡πà ‚Üí ‡∏•‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏Å‡πà‡∏≤
      if (newImage && existingMenu.image) {
        const oldImagePath = path.join(__dirname, 'uploads', path.basename(existingMenu.image));
        if (fs.existsSync(oldImagePath)) {
          fs.unlinkSync(oldImagePath);
          console.log('[%s] Deleted old image: %s', new Date().toISOString(), oldImagePath);
        }
      }

      // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
      const updatedFields = {
        category: category || existingMenu.category,
        name_tha: name_tha || existingMenu.name_tha,
        name_eng: name_eng || existingMenu.name_eng,
        short_description: short_description || existingMenu.short_description,
        full_description: full_description || existingMenu.full_description,
        price_starts_at: price_starts_at ? parseFloat(price_starts_at) : existingMenu.price_starts_at,
        tags: tags || existingMenu.tags,
        image: newImage || existingMenu.image
      };

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏°‡∏ô‡∏π
      await connection.query(
        `UPDATE menu SET category = ?, name_tha = ?, name_eng = ?, short_description = ?, 
         full_description = ?, price_starts_at = ?, tags = ?, image = ? WHERE id = ?`,
        [
          updatedFields.category,
          updatedFields.name_tha,
          updatedFields.name_eng,
          updatedFields.short_description,
          updatedFields.full_description,
          updatedFields.price_starts_at,
          updatedFields.tags,
          updatedFields.image,
          menuId
        ]
      );

      console.log('[%s] Menu updated for ID %s', new Date().toISOString(), menuId);

      // ‡∏î‡∏∂‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
      const [updatedRows] = await connection.query('SELECT * FROM menu WHERE id = ?', [menuId]);
      connection.release();

      res.json(updatedRows[0]);
    } catch (error) {
      console.error('[%s] Error in PATCH /api/admin/menu/:id:', new Date().toISOString(), error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });
});

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î 
app.get('/api/admin/orders', async (req, res) => {
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô`);

    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á orders ‡πÇ‡∏î‡∏¢‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö order_time ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô HH:MM
    const [orderRows] = await connection.query(
      `SELECT o.id, o.order_number, o.status, TIME_FORMAT(o.order_time, '%H:%i') AS order_time
       FROM orders o
       ORDER BY o.order_time DESC`
    );

    console.log('orderRows:', orderRows);

    if (orderRows.length === 0) {
      connection.release();
      console.log(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏î ‡πÜ ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö`);
      return res.status(404).json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' });
    }

    // 2. ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏±‡πâ‡∏ô
    for (let order of orderRows) {
      const [orderItems] = await connection.query(
        `SELECT COUNT(*) AS total_items
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.id]
      );
      order.total_items = orderItems[0].total_items;
    }

    // 3. ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡∏•‡∏±‡∏ö
    console.log('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå:', orderRows);

    res.json({
      orders: orderRows.map(order => ({
        order_number: order.order_number,
        total_items: order.total_items,
        status: order.status,
        order_time: order.order_time
      }))
    });

  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô GET /api/admin/orders:', new Date().toISOString(), err);
    res.status(500).json({ error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå' });
  }
});

// ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏°‡∏ô‡∏π
app.get('/api/admin/order/:order_id', async (req, res) => {
  const { order_id } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Fetching admin view of order_id ${order_id}`);

    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• order
    const [orderRows] = await connection.query(
      `SELECT o.order_number, o.table_number, o.status, o.order_date,
              TIME_FORMAT(o.order_time, '%H:%i') AS order_time
       FROM orders o
       WHERE o.id = ?`,
      [order_id]
    );

    if (orderRows.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'Order not found' });
    }

    const order = orderRows[0];

    // 2. ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£
    const [orderItems] = await connection.query(
      `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name,
              oi.option AS meat_option, oi.quantity, oi.price_each
       FROM order_items oi
       WHERE oi.order_id = ?`,
      [order_id]
    );

    if (orderItems.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'No items found for this order' });
    }

    // 3. ‡∏î‡∏∂‡∏á addons + ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì total ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
    for (let item of orderItems) {
      const [addons] = await connection.query(
        `SELECT addon_name, addon_price
         FROM order_item_addons
         WHERE order_item_id = ?`,
        [item.order_item_id]
      );

      item.addons = addons.map(a => a.addon_name).join(', ');
      const addonTotal = addons.reduce((sum, a) => sum + Number(a.addon_price), 0);
      item.total_price = (item.quantity * Number(item.price_each)) + addonTotal;
      item.image = null; // ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏°‡∏µ
    }

    // 4. ‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    const grand_total = orderItems.reduce((sum, item) => sum + item.total_price, 0);

    // 5. ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö
    res.json({
      order_number: order.order_number,
      table_no: order.table_number,
      status: order.status,
      order_date: order.order_date,
      order_time: order.order_time,
      items: orderItems.map(item => ({
        menu_name: item.menu_name,
        quantity: item.quantity,
        total_price: item.total_price,
        addons: item.addons,
        meat_option: item.meat_option || null,
        image: item.image
      })),
      grand_total: grand_total.toFixed(2)
    });

    connection.release();
  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] Error in GET /api/admin/order/:order_id:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°
app.put('/api/admin/order/:order_id/:status', async (req, res) => {
  const { order_id, status } = req.params;
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ status ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏°‡∏≤‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  const validStatuses = ['orderplaced', 'preparing', 'served'];
  if (!validStatuses.includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }

  let connection;
  try {
    connection = await pool.getConnection();
    console.log(`Updating status to ${status} for order ${order_id}`);

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const [result] = await connection.query(
      `UPDATE orders SET status = ? WHERE id = ?`,
      [status, order_id]
    );

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (result.affectedRows === 0) {
      return res.status(404).json({ error: 'Order not found' });
    }

    // ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö
    res.json({ message: `Order ${order_id} status updated to ${status}` });

  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] Error in updating order status:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏ï‡πä‡∏∞
app.get('/api/admin/tables', async (req, res) => {
  let connection;
  try {
    connection = await pool.getConnection();

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡πÇ‡∏ï‡πä‡∏∞ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏ï‡πä‡∏∞
    const [tables] = await connection.query(`
      SELECT 
        t.table_no,
        t.status,
        COALESCE(SUM(oi.quantity * oi.price_each + IFNULL(addon_total.total_addon, 0)), 0) AS total_price
      FROM tables t
      LEFT JOIN orders o ON o.table_number = t.table_no
      LEFT JOIN order_items oi ON oi.order_id = o.id
      LEFT JOIN (
        SELECT 
          oia.order_item_id,
          SUM(oia.addon_price) AS total_addon
        FROM order_item_addons oia
        GROUP BY oia.order_item_id
      ) addon_total ON addon_total.order_item_id = oi.id
      GROUP BY t.table_no, t.status
      ORDER BY t.table_no;
    `);

    res.json(tables);
  } catch (err) {
    console.error('[%s] Error in GET /api/admin/tables:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) connection.release();
  }
});

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏¥‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡πÇ‡∏ï‡πä‡∏∞
app.get('/api/admin/bills-summary/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Admin request: bills summary for table ${table_no}`);

    const [orderRows] = await connection.query(
      `SELECT o.*, t.table_no
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    if (orderRows.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'No orders found for this table' });
    }

    let bills = [];
    let grandTotal = 0;

    for (let order of orderRows) {
      const [orderItems] = await connection.query(
        `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name, oi.option AS meat_option, oi.quantity, oi.price_each
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.id]
      );

      for (let item of orderItems) {
        const [addons] = await connection.query(
          `SELECT addon_name, addon_price
           FROM order_item_addons
           WHERE order_item_id = ?`,
          [item.order_item_id]
        );

        const addonTotal = addons.reduce((sum, addon) => sum + Number(addon.addon_price), 0);
        item.total_price = (item.price_each * item.quantity) + addonTotal;
      }

      const subtotal = orderItems.reduce((sum, item) => sum + item.total_price, 0);
      const vat = subtotal * 0.07;
      const total = subtotal + vat;
      grandTotal += total;

      bills.push({
        order_number: order.order_number,
        total: total.toFixed(2)
      });
    }

    if (bills.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'No items found for this table' });
    }

    res.json({
      table_no,
      bills,
      grand_total: grandTotal.toFixed(2)
    });

  } catch (err) {
    console.error(`[${new Date().toISOString()}] Error in GET /api/admin/bills-summary/:table_no:`, err);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) connection.release();
  }
});

// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏¥‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ö‡∏¥‡∏•
app.get('/api/admin/bill/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Admin request: Fetching bill details for table ${table_no}`);

    const [orderRows] = await connection.query(
      `SELECT o.*, t.table_no
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    if (orderRows.length === 0) {
      return res.status(404).json({ error: 'No orders found for this table' });
    }

    let bills = [];

    for (let order of orderRows) {
      const [orderItems] = await connection.query(
        `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name, oi.option AS meat_option, oi.quantity, oi.price_each
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.id]
      );

      for (let item of orderItems) {
        const [addons] = await connection.query(
          `SELECT addon_name, addon_price
           FROM order_item_addons
           WHERE order_item_id = ?`,
          [item.order_item_id]
        );

        item.addons = addons.map(a => a.addon_name).join(', ') || '';
        const addonTotal = addons.reduce((sum, a) => sum + Number(a.addon_price), 0);
        item.total_price = (Number(item.price_each) * item.quantity) + addonTotal;
      }

      const subtotal = orderItems.reduce((sum, item) => sum + item.total_price, 0);
      const vat = subtotal * 0.07;
      const total = subtotal + vat;

      bills.push({
        order_number: order.order_number,
        table_no: order.table_no,
        order_date: order.order_date,
        order_time: order.order_time,
        items: orderItems.map(item => ({
          menu_name: item.menu_name,
          quantity: item.quantity,
          price_each: item.price_each,
          total_price: item.total_price,
          addons: item.addons,
          meat_option: item.meat_option || null,
        })),
        subtotal: subtotal.toFixed(2),
        vat: vat.toFixed(2),
        total: total.toFixed(0),
      });
    }

    if (bills.length === 0) {
      return res.status(404).json({ error: 'No items found for this table' });
    }

    res.json({
      table_no,
      bills
    });

  } catch (err) {
    console.error(`[${new Date().toISOString()}] Error in GET /api/admin/bill/:table_no:`, err);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) connection.release();
  }
});


// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏î paid ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡∏∑‡∏ó‡∏¥‡πâ‡∏á ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö ‡∏•‡∏ö‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤ ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÇ‡∏ï‡πä‡∏∞‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏Å‡πá‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏ï‡πä‡∏∞‡∏ß‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á
// ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏ï‡πä‡∏∞ ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÇ‡∏ï‡πä‡∏∞‡πÄ‡∏õ‡πá‡∏ô Available
app.delete('/api/clear-table/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    await connection.beginTransaction();

    console.log(`Clearing all data related to table ${table_no}`);

    // 1. ‡∏•‡∏ö addons ‡∏Ç‡∏≠‡∏á order items (‡∏°‡∏µ ON DELETE CASCADE ‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏ä‡∏±‡∏î‡πÜ)
    const [orders] = await connection.query(
      `SELECT id FROM orders WHERE table_number = ?`,
      [table_no]
    );

    const orderIds = orders.map(order => order.id);

    if (orderIds.length > 0) {
      // ‡∏•‡∏ö order item addons
      await connection.query(
        `DELETE FROM order_item_addons WHERE order_item_id IN (
          SELECT id FROM order_items WHERE order_id IN (?)
        )`,
        [orderIds]
      );

      // ‡∏•‡∏ö order items
      await connection.query(
        `DELETE FROM order_items WHERE order_id IN (?)`,
        [orderIds]
      );

      // ‡∏•‡∏ö orders
      await connection.query(
        `DELETE FROM orders WHERE id IN (?)`,
        [orderIds]
      );
    }

    // 2. ‡∏•‡∏ö cart item addons
    await connection.query(
      `DELETE FROM cart_item_addons WHERE cart_item_id IN (
        SELECT ci.id FROM cart_items ci
        JOIN carts c ON ci.cart_id = c.id
        WHERE c.table_no = ?
      )`,
      [table_no]
    );

    // 3. ‡∏•‡∏ö cart items
    await connection.query(
      `DELETE ci FROM cart_items ci
       JOIN carts c ON ci.cart_id = c.id
       WHERE c.table_no = ?`,
      [table_no]
    );

    // 4. ‡∏•‡∏ö carts
    await connection.query(
      `DELETE FROM carts WHERE table_no = ?`,
      [table_no]
    );

    // 5. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÇ‡∏ï‡πä‡∏∞‡πÄ‡∏õ‡πá‡∏ô Available
    await connection.query(
      `UPDATE tables SET status = 'Available', scanned_at = NULL WHERE table_no = ?`,
      [table_no]
    );

    await connection.commit();
    connection.release();

    console.log(`Successfully cleared data and released table ${table_no}`);
    res.json({ message: `Table ${table_no} cleared and set to Available.` });

  } catch (err) {
    if (connection) {
      await connection.rollback();
      connection.release();
    }
    console.error(`[${new Date().toISOString()}] Error in DELETE /api/clear-table/:table_no:`, err);
    res.status(500).json({ error: 'Internal server error' });
  }
});


// // 1. GET /admin/orders - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
// app.get('/admin/orders', async (req, res) => {
//   let connection;

//   try {
//     connection = await pool.getConnection();

//     // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡πà‡∏≤‡∏á‡πÜ
//     const [orders] = await connection.query(
//       'SELECT * FROM orders ORDER BY order_date DESC, order_time DESC'
//     );

//     // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
//     if (orders.length === 0) {
//       return res.status(404).json({ error: 'No orders found' });
//     }

//     connection.release();
//     res.json(orders);

//   } catch (err) {
//     if (connection) {
//       connection.release();
//     }
//     console.error('[%s] Error in GET /admin/orders:', new Date().toISOString(), err);
//     res.status(500).json({ error: 'Internal server error' });
//   }
// });

// // 2. GET /admin/orders/:orderId - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏° orderId ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ order_item ‡πÅ‡∏•‡∏∞ addon
// app.get('/admin/orders/:orderId', async (req, res) => {
//   const { orderId } = req.params;
//   let connection;

//   try {
//     connection = await pool.getConnection();

//     // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
//     const [orderRows] = await connection.query(
//       'SELECT * FROM orders WHERE id = ?',
//       [orderId]
//     );
    
//     // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
//     if (orderRows.length === 0) {
//       return res.status(404).json({ error: 'Order not found' });
//     }

//     const order = orderRows[0];

//     // 2. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á order_items ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ
//     const [orderItems] = await connection.query(
//       'SELECT * FROM order_items WHERE order_id = ?',
//       [orderId]
//     );

//     // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ
//     if (orderItems.length === 0) {
//       return res.status(404).json({ error: 'No items found for this order' });
//     }

//     // 3. ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ order_item ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• addon ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á
//     for (let item of orderItems) {
//       const [addons] = await connection.query(
//         'SELECT * FROM order_item_addons WHERE order_item_id = ?',
//         [item.id]
//       );
//       item.addons = addons;  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• addon ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ item
//     }

//     // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á order ‡∏û‡∏£‡πâ‡∏≠‡∏° order_items ‡πÅ‡∏•‡∏∞ addons
//     connection.release();
//     res.json({
//       order,
//       order_items: orderItems
//     });

//   } catch (err) {
//     if (connection) {
//       connection.release();
//     }
//     console.error('[%s] Error in GET /admin/orders/:orderId:', new Date().toISOString(), err);
//     res.status(500).json({ error: 'Internal server error' });
//   }
// });

// // Endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
// app.post('/admin/api/orders/:orderId/update-status', async (req, res) => {
//   const { orderId } = req.params;
//   const { status } = req.body;  // ‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å body ‡∏Ç‡∏≠‡∏á request
//   let connection;

//   try {
//     if (!status) {
//       return res.status(400).json({ error: 'Missing status' });
//     }

//     // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ status ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
//     const validStatuses = ['Order Placed', 'Preparing', 'Served'];
//     if (!validStatuses.includes(status)) {
//       return res.status(400).json({ error: 'Invalid status' });
//     }

//     connection = await pool.getConnection();
//     await connection.beginTransaction();

//     // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
//     const [orderRows] = await connection.query(
//       'SELECT * FROM orders WHERE id = ?',
//       [orderId]
//     );
//     if (orderRows.length === 0) {
//       await connection.rollback();
//       connection.release();
//       return res.status(404).json({ error: 'Order not found' });
//     }

//     // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
//     const currentStatus = orderRows[0].status;
//     if (
//       (currentStatus === 'Preparing' && status === 'Order Placed') ||
//       (currentStatus === 'Served' && status !== 'Served')
//     ) {
//       return res.status(400).json({
//         error: 'Invalid status transition. Cannot revert to previous status.',
//       });
//     }

//     // 2. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á orders
//     await connection.query(
//       'UPDATE orders SET status = ? WHERE id = ?',
//       [status, orderId]
//     );

//     // 3. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô order_items ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
//     await connection.query(
//       'UPDATE order_items SET status = ? WHERE order_id = ?',
//       [status, orderId]
//     );

//     await connection.commit();
//     connection.release();

//     res.json({ message: 'Order status updated successfully' });

//   } catch (err) {
//     if (connection) {
//       await connection.rollback();
//       connection.release();
//     }
//     console.error('Error in POST /admin/api/orders/:orderId/update-status:', err);
//     res.status(500).json({ error: 'Internal server error' });
//   }
// });

// BillDetails



// --------------------------------------------------------------------Get data--------------------------------------------------------
app.get('/api/orders/:orderId', async (req, res) => {
  const { orderId } = req.params;  // ‡∏£‡∏±‡∏ö orderId ‡∏à‡∏≤‡∏Å URL parameters
  let connection;

  try {
    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    connection = await pool.getConnection();

    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å
    const [orderRows] = await connection.query(
      'SELECT * FROM orders WHERE id = ?',
      [orderId]
    );
    if (orderRows.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'Order not found' });
    }
    const order = orderRows[0];

    // 2. ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ order_items ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ
    const [orderItems] = await connection.query(
      'SELECT * FROM order_items WHERE order_id = ?',
      [orderId]
    );
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ order_items ‡∏û‡∏£‡πâ‡∏≠‡∏° addons ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á
    const orderItemsWithAddons = [];

    for (const item of orderItems) {
      // 3. ‡∏î‡∏∂‡∏á addons ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö order_item ‡∏ô‡∏µ‡πâ
      const [addons] = await connection.query(
        'SELECT * FROM order_item_addons WHERE order_item_id = ?',
        [item.id]
      );

      const itemWithAddons = {
        ...item,
        addons: addons.map(addon => ({
          addon_name: addon.addon_name,
          addon_price: addon.addon_price
        }))
      };

      orderItemsWithAddons.push(itemWithAddons);
    }

    // 4. ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏°‡∏≤‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    res.json({
      order: {
        id: order.id,
        order_number: order.order_number,
        table_number: order.table_number,
        status: order.status,
        order_date: order.order_date,
        order_time: order.order_time,
        total_price: order.total_price
      },
      order_items: orderItemsWithAddons
    });

  } catch (err) {
    console.error('Error in GET /api/orders/:orderId:', err);
    if (connection) {
      connection.release();
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});
// ------------------------------------------------------------------ User Get Options ------------------------------------------------------------------
app.get('/api/options', async (req, res) => {
  try {
    const [meatOptions] = await pool.query('SELECT id, name, extra_price FROM meat_options');
    const [addonOptions] = await pool.query('SELECT id, name, extra_price FROM addon_options');
    console.log('meatOptions:', JSON.stringify(meatOptions, null, 2));
    console.log('addonOptions:', JSON.stringify(addonOptions, null, 2));
    res.json({ meat_options: meatOptions, addon_options: addonOptions });
  } catch (err) {
    console.error('Error in /api/options:', err.message, err.stack);
    res.status(500).json({ error: 'Failed to fetch menu options' });
  }
});

// ------------------------------------------------------------------ Table ------------------------------------------------------------------
app.post('/api/tables/scan', async (req, res) => {
  try {
    let { table_no } = req.body;

    // ‚úÖ Validate table_no ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡πÅ‡∏Ñ‡πà '01' ‡∏ñ‡∏∂‡∏á '12' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    const validTableNumbers = Array.from({ length: 12 }, (_, i) => String(i + 1).padStart(2, '0'));
    if (!validTableNumbers.includes(table_no)) {
      return res.status(400).json({ error: 'Invalid table number' });
    }

    if (!table_no) {
      return res.status(400).json({ error: 'Table number is required' });
    }

    const connection = await pool.getConnection();

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏ï‡πä‡∏∞‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const [existing] = await connection.query(
      'SELECT status FROM tables WHERE table_no = ?',
      [table_no]
    );

    if (existing.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'Table not found' });
    }

    if (existing[0].status === 'Occupied') {
      connection.release();
      return res.status(400).json({ error: 'Table is already occupied' });
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï status ‡πÄ‡∏õ‡πá‡∏ô "Occupied" ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï scanned_at
    const [result] = await connection.query(
      'UPDATE tables SET status = "Occupied", scanned_at = NOW() WHERE table_no = ?',
      [table_no]
    );

    connection.release();

    if (result.affectedRows === 0) {
      return res.status(500).json({ error: 'Failed to update table status' });
    }

    console.log('[%s] Table %s scanned and occupied', new Date().toISOString(), table_no);
    res.json({ message: `Table ${table_no} status updated to Occupied` });
  } catch (err) {
    console.error('[%s] Error in POST /api/tables/scan:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});
// ------------------------------------------------------------------ User -----------------------------------------------------------------------
// Add cart
app.post('/api/cart/add', async (req, res) => {
  let connection;
  try {
    const { table_no, menu_id, meat_option_id, quantity, addon_option_ids } = req.body;

    // ‚úÖ Validate input
    if (!table_no || !menu_id || !quantity) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (quantity < 1) {
      return res.status(400).json({ error: 'Quantity must be at least 1' });
    }

    const validTableNumbers = Array.from({ length: 12 }, (_, i) => String(i + 1).padStart(2, '0'));
    if (!validTableNumbers.includes(table_no)) {
      return res.status(400).json({ error: 'Invalid table number' });
    }

    connection = await pool.getConnection();
    await connection.beginTransaction();

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏ï‡πä‡∏∞‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ
    const [tableRows] = await connection.query(
      'SELECT table_no, status FROM tables WHERE table_no = ?',
      [table_no]
    );
    if (tableRows.length === 0 || tableRows[0].status !== 'Occupied') {
      await connection.rollback();
      return res.status(400).json({ error: 'Invalid or unoccupied table' });
    }

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á cart
    let [cartRows] = await connection.query('SELECT id FROM carts WHERE table_no = ?', [table_no]);
    let cartId;
    if (cartRows.length === 0) {
      const [cartResult] = await connection.query(
        'INSERT INTO carts (table_no, created_at) VALUES (?, NOW())',
        [table_no]
      );
      cartId = cartResult.insertId;
    } else {
      cartId = cartRows[0].id;
    }

    // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏ô‡∏π
    const [menuRows] = await connection.query(
      'SELECT name_eng, price_starts_at FROM menu WHERE id = ?',
      [menu_id]
    );
    if (menuRows.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Menu not found' });
    }

    const menuName = menuRows[0].name_eng;  // ‡πÉ‡∏ä‡πâ name_eng
    let totalPrice = parseFloat(menuRows[0].price_starts_at);  // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡πÄ‡∏°‡∏ô‡∏π

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏°‡∏ô‡∏π‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    if (isNaN(totalPrice)) {
      await connection.rollback();
      return res.status(400).json({ error: 'Invalid price for menu item' });
    }

    // ‚úÖ ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏ô‡∏∑‡πâ‡∏≠ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    let meatOptionPrice = 0;
    if (meat_option_id) {
      const [meatRows] = await connection.query(
        'SELECT extra_price FROM meat_options WHERE id = ?',
        [meat_option_id]
      );
      if (meatRows.length === 0) {
        await connection.rollback();
        return res.status(404).json({ error: 'Meat option not found' });
      }
      meatOptionPrice = parseFloat(meatRows[0].extra_price);  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
      totalPrice += meatOptionPrice; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤
    }

    // ‚úÖ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° addon
    const addons = [];
    if (addon_option_ids && Array.isArray(addon_option_ids)) {
      for (const addonId of addon_option_ids) {
        const [addonRows] = await connection.query(
          'SELECT extra_price FROM addon_options WHERE id = ?',
          [addonId]
        );
        if (addonRows.length === 0) {
          await connection.rollback();
          return res.status(404).json({ error: `Addon option ID ${addonId} not found` });
        }
        const addonPrice = parseFloat(addonRows[0].extra_price);  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
        totalPrice += addonPrice;

        addons.push({ addon_option_id: addonId, price: addonPrice.toFixed(2) });  // ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
      }
    }

    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ cart_items ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏±‡πâ‡∏á meat_option_id
    const [cartItemResult] = await connection.query(
      `INSERT INTO cart_items (cart_id, menu_id, menu_name, quantity, total_price, meat_option_id, created_at)
       VALUES (?, ?, ?, ?, ?, ?, NOW())`,
      [cartId, menu_id, menuName, quantity, totalPrice.toFixed(2), meat_option_id || null]  // total_price ‡πÅ‡∏ó‡∏ô price_each
    );
    const cartItemId = cartItemResult.insertId;

    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° addon ‡πÅ‡∏¢‡∏Å
    for (const addon of addons) {
      await connection.query(
        `INSERT INTO cart_item_addons (cart_item_id, addon_option_id, price)
         VALUES (?, ?, ?)`,
        [cartItemId, addon.addon_option_id, addon.price]
      );
    }

    await connection.commit();
    connection.release();

    res.json({
      message: 'Item added to cart successfully',
      cart_id: cartId,
      menu_name: menuName,
      quantity,
      total_price: totalPrice.toFixed(2),  // ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
      addons,
    });

  } catch (err) {
    if (connection) {
      await connection.rollback();
      connection.release();
    }
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});
// Update quality
app.put('/api/cart/update', async (req, res) => {
  let connection;
  try {
    const { cart_item_id, quantity } = req.body;

    // ‚úÖ Validate input
    if (!cart_item_id || !quantity) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (quantity < 1) {
      return res.status(400).json({ error: 'Quantity must be at least 1' });
    }

    connection = await pool.getConnection();
    await connection.beginTransaction();

    // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• cart_item
    const [cartItemRows] = await connection.query(
      'SELECT ci.menu_id, ci.menu_name, ci.total_price FROM cart_items ci WHERE ci.id = ?',
      [cart_item_id]
    );

    if (cartItemRows.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Cart item not found' });
    }

    const cartItem = cartItemRows[0];
    const menuId = cartItem.menu_id;

    // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏ô‡∏π
    const [menuRows] = await connection.query(
      'SELECT price_starts_at FROM menu WHERE id = ?',
      [menuId]
    );
    if (menuRows.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Menu not found' });
    }

    const pricePerItem = parseFloat(menuRows[0].price_starts_at);

    if (isNaN(pricePerItem)) {
      await connection.rollback();
      return res.status(400).json({ error: 'Invalid price' });
    }

    // ‚úÖ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô (quantity)
    const newTotalPrice = pricePerItem * quantity;

    // ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    await connection.query(
      `UPDATE cart_items SET quantity = ?, total_price = ? WHERE id = ?`,
      [quantity, newTotalPrice.toFixed(2), cart_item_id]
    );

    await connection.commit();
    connection.release();

    res.json({
      message: 'Cart item updated successfully',
      cart_item_id,
      quantity,
      total_price: newTotalPrice.toFixed(2),
    });

  } catch (err) {
    if (connection) {
      await connection.rollback();
      connection.release();
    }
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/cart/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();

    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cart ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏°‡∏±‡πâ‡∏¢
    const [cartRows] = await connection.query(
      'SELECT id FROM carts WHERE table_no = ?',
      [table_no]
    );

    if (cartRows.length === 0) {
      console.log(`Cart not found for table_no: ${table_no}`);
      connection.release();
      return res.status(404).json({ error: `Your cart was not found` });
    }

    const cartId = cartRows[0].id;

    // 2. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á menu
    const [items] = await connection.query(
      `SELECT ci.id AS cart_item_id, ci.menu_id, ci.menu_name, ci.quantity, ci.total_price,
              mo.name AS meat_option_name, m.image AS menu_image
       FROM cart_items ci
       LEFT JOIN meat_options mo ON ci.meat_option_id = mo.id
       LEFT JOIN menu m ON ci.menu_id = m.id
       WHERE ci.cart_id = ?`,
      [cartId]
    );

    // 3. ‡∏î‡∏∂‡∏á add-ons ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ cart_item
    for (let item of items) {
      const [addonRows] = await connection.query(
        `SELECT ao.name, ao.extra_price
         FROM cart_item_addons cia
         JOIN addon_options ao ON cia.addon_option_id = ao.id
         WHERE cia.cart_item_id = ?`,
        [item.cart_item_id]
      );

      item.addons = addonRows.map(addon => addon.name).join(', ');
      item.meat_option = item.meat_option_name || '';
      item.image = item.menu_image || ''; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå image
      item.total_price = parseFloat(item.total_price); // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏Ñ‡∏≤

      // ‡∏•‡∏ö‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
      delete item.meat_option_name;
      delete item.cart_item_id;
      delete item.menu_image;
      delete item.menu_id;
    }

    // 4. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°
    const grand_total = items.reduce((sum, item) => sum + item.total_price, 0);

    res.json({
      table_no,
      items,
      grand_total,
    });

  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] Error in GET /api/cart/:table_no:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ‡∏ï‡∏≠‡∏ô‡∏Å‡∏î checkout ---------------------------------------------------------------------------
app.post('/api/cart/checkout', async (req, res) => {
  const { table_no } = req.body;
  let connection;

  try {
    if (!table_no) return res.status(400).json({ error: 'Missing table_no' });

    connection = await pool.getConnection();
    await connection.beginTransaction();

    // 1. ‡∏î‡∏∂‡∏á cart
    const [cartRows] = await connection.query(
      'SELECT id FROM carts WHERE table_no = ?',
      [table_no]
    );
    if (cartRows.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Cart not found for table' });
    }
    const cartId = cartRows[0].id;

    // 2. ‡∏î‡∏∂‡∏á cart_items
    const [cartItems] = await connection.query(
      'SELECT * FROM cart_items WHERE cart_id = ?',
      [cartId]
    );
    if (cartItems.length === 0) {
      await connection.rollback();
      return res.status(400).json({ error: 'Cart is empty' });
    }

    // 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á order
    const orderNumber = `ORD-${Date.now()}`;
    const [orderResult] = await connection.query(
      `INSERT INTO orders (order_number, table_number, status, order_date, order_time, total_price)
       VALUES (?, ?, 'orderplaced', CURDATE(), CURTIME(), 0.00)`,
      [orderNumber, table_no]
    );
    const orderId = orderResult.insertId;

    let totalPrice = 0;

    // 4. Loop cart_items -> order_items
    for (const item of cartItems) {
      let optionText = null;

      if (item.meat_option_id) {
        const [meatRows] = await connection.query(
          'SELECT name FROM meat_options WHERE id = ?',
          [item.meat_option_id]
        );
        optionText = meatRows[0]?.name || null;
      }

      const priceEach = parseFloat(item.total_price) / item.quantity;

      const [orderItemResult] = await connection.query(
        `INSERT INTO order_items (order_id, menu_id, menu_name, \`option\`, quantity, price_each)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [
          orderId,
          item.menu_id,
          item.menu_name,
          optionText,
          item.quantity,
          priceEach.toFixed(2)
        ]
      );
      const orderItemId = orderItemResult.insertId;
      totalPrice += priceEach * item.quantity;

      // 5. ‡πÄ‡∏û‡∏¥‡πà‡∏° addon
      const [addons] = await connection.query(
        'SELECT * FROM cart_item_addons WHERE cart_item_id = ?',
        [item.id]
      );

      for (const addon of addons) {
        const [addonDetail] = await connection.query(
          'SELECT name FROM addon_options WHERE id = ?',
          [addon.addon_option_id]
        );
        const addonName = addonDetail[0]?.name || 'Unknown';

        await connection.query(
          `INSERT INTO order_item_addons (order_item_id, addon_name, addon_price)
           VALUES (?, ?, ?)`,
          [orderItemId, addonName, addon.price]
        );

        totalPrice += parseFloat(addon.price);
      }
    }

    // 6. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏ô orders
    await connection.query(
      'UPDATE orders SET total_price = ? WHERE id = ?',
      [totalPrice.toFixed(2), orderId]
    );

    // 7. ‡∏•‡πâ‡∏≤‡∏á cart
    await connection.query('DELETE FROM cart_item_addons WHERE cart_item_id IN (SELECT id FROM cart_items WHERE cart_id = ?)', [cartId]);
    await connection.query('DELETE FROM cart_items WHERE cart_id = ?', [cartId]);
    await connection.query('DELETE FROM carts WHERE id = ?', [cartId]);
    await connection.commit();
    connection.release();

    res.json({ message: 'Checkout successful', order_id: orderId, total_price: totalPrice.toFixed(2) });

  } catch (err) {
    if (connection) {
      await connection.rollback();
      connection.release();
    }
    console.error('[%s] Error in POST /api/cart/checkout:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// OrderDetails
app.get('/api/order/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Connection successful. Fetching orders for table ${table_no}`);

    // 1. Fetch orders for the given table number
    const [orderRows] = await connection.query(
      `SELECT o.*, t.table_no
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    console.log('orderRows:', orderRows);

    if (orderRows.length === 0) {
      connection.release();
      console.log(`No orders found for table ${table_no}`);
      return res.status(404).json({ error: 'Order not found for this table' });
    }

    // 2. Fetch order items based on order_id
    const [orderItems] = await connection.query(
      `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name, oi.option AS meat_option, oi.quantity, oi.price_each
       FROM order_items oi
       WHERE oi.order_id = ?`,
      [orderRows[0].id]
    );

    console.log('orderItems:', orderItems);

    if (orderItems.length === 0) {
      connection.release();
      console.log(`No items found for order ${orderRows[0].id}`);
      return res.status(404).json({ error: 'No items found for this order' });
    }

    // 3. Fetch order item addons and calculate total price including addon price
    for (let item of orderItems) {
      const [addons] = await connection.query(
        `SELECT oia.addon_name, oia.addon_price
         FROM order_item_addons oia
         WHERE oia.order_item_id = ?`,
        [item.order_item_id]
      );

      console.log(`addons for item ${item.order_item_id}:`, addons);

      // Convert addons to a string separated by commas
      item.addons = addons.length > 0 ? addons.map(addon => addon.addon_name).join(', ') : '';

      // Calculate total price: (price_each * quantity) + sum(addon_price)
      const addonTotal = addons.reduce((sum, addon) => sum + Number(addon.addon_price), 0);
      item.total_price = (Number(item.price_each) * item.quantity) + addonTotal;
      item.image = null; // Assuming no image data for now
    }

    // 4. Calculate grand total by summing up the total_price of each item
    const grand_total = orderItems.reduce((sum, item) => sum + item.total_price, 0);

    // 5. Send response in the desired structure, including orders table data
    console.log('Returning order and items data:', {
      order_number: orderRows[0].order_number,
      table_no: orderRows[0].table_no,
      status: orderRows[0].status,
      order_date: orderRows[0].order_date,
      order_time: orderRows[0].order_time,
      items: orderItems.map(item => ({
        menu_name: item.menu_name,
        quantity: item.quantity,
        total_price: item.total_price,
        addons: item.addons,
        meat_option: item.meat_option || null,
        image: item.image
      })),
      grand_total
    });

    res.json({
      order_number: orderRows[0].order_number,
      table_no: orderRows[0].table_no,
      status: orderRows[0].status,
      order_date: orderRows[0].order_date,
      order_time: orderRows[0].order_time,
      items: orderItems.map(item => ({
        menu_name: item.menu_name,
        quantity: item.quantity,
        total_price: item.total_price,
        addons: item.addons,
        meat_option: item.meat_option || null,
        image: item.image
      })),
      grand_total
    });

  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] Error in GET /api/orders/:table_no:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Order Status 
app.get('/api/order-status/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏ï‡πä‡∏∞ ${table_no}`);

    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÇ‡∏ï‡πä‡∏∞‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    const [orderRows] = await connection.query(
      `SELECT o.id AS order_id, o.order_number, o.status
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    console.log('orderRows:', orderRows);

    if (orderRows.length === 0) {
      connection.release();
      console.log(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏ï‡πä‡∏∞ ${table_no}`);
      return res.status(404).json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏ï‡πä‡∏∞‡∏ô‡∏µ‡πâ' });
    }

    // 2. ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠ ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ô‡∏±‡πâ‡∏ô
    for (let order of orderRows) {
      const [orderItems] = await connection.query(
        `SELECT COUNT(*) AS total_items
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.order_id]
      );
      order.total_items = orderItems[0].total_items;
    }

    // 3. ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Å‡∏•‡∏±‡∏ö
    console.log('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠:', orderRows);

    res.json({
      table_no: table_no,
      orders: orderRows.map(order => ({
        order_id: order.order_id,
        order_number: order.order_number,
        total_items: order.total_items,
        status: order.status
      }))
    });

  } catch (err) {
    if (connection) connection.release();
    console.error('[%s] ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô GET /api/order-status/:table_no:', new Date().toISOString(), err);
    res.status(500).json({ error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå' });
  }
});

// BillDetails
app.get('/api/bill/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Connection successful. Fetching bills for table ${table_no}`);

    // 1. Fetch all orders for the given table number
    const [orderRows] = await connection.query(
      `SELECT o.*, t.table_no
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    console.log('orderRows:', orderRows);

    if (orderRows.length === 0) {
      connection.release();
      console.log(`No orders found for table ${table_no}`);
      return res.status(404).json({ error: 'Order not found for this table' });
    }

    // 2. Initialize array to store all bills
    let bills = [];

    // 3. Loop through each order and calculate bill details
    for (let order of orderRows) {
      // Fetch order items for this order
      const [orderItems] = await connection.query(
        `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name, oi.option AS meat_option, oi.quantity, oi.price_each
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.id]
      );

      console.log(`orderItems for order ${order.id}:`, orderItems);

      if (orderItems.length === 0) continue; // Skip if no items in this order

      // 4. Fetch addons and calculate total price for each item
      for (let item of orderItems) {
        const [addons] = await connection.query(
          `SELECT oia.addon_name, oia.addon_price
           FROM order_item_addons oia
           WHERE oia.order_item_id = ?`,
          [item.order_item_id]
        );

        console.log(`addons for item ${item.order_item_id}:`, addons);

        // Convert addons to a string separated by commas
        item.addons = addons.length > 0 ? addons.map(addon => addon.addon_name).join(', ') : '';

        // Calculate total price for the item: (price_each * quantity) + sum(addon_price)
        const addonTotal = addons.reduce((sum, addon) => sum + Number(addon.addon_price), 0);
        item.total_price = (Number(item.price_each) * item.quantity) + addonTotal;
      }

      // 5. Calculate subtotal for this order
      const subtotal = orderItems.reduce((sum, item) => sum + item.total_price, 0);

      // 6. Calculate VAT (7%) and total for this order
      const vatRate = 0.07;
      const vat = subtotal * vatRate;
      const total = subtotal + vat;

      // 7. Add bill details to the bills array
      bills.push({
        order_number: order.order_number,
        table_no: order.table_no,
        order_date: order.order_date,
        order_time: order.order_time,
        items: orderItems.map(item => ({
          menu_name: item.menu_name,
          quantity: item.quantity,
          price_each: item.price_each,
          total_price: item.total_price,
          addons: item.addons,
          meat_option: item.meat_option || null,
        })),
        subtotal: subtotal.toFixed(2),
        vat: vat.toFixed(2),
        total: total.toFixed(0),
      });
    }

    if (bills.length === 0) {
      connection.release();
      console.log(`No items found for table ${table_no}`);
      return res.status(404).json({ error: 'No items found for this table' });
    }

    // 8. Send response with all bills for the table
    console.log('Returning bills data for table:', { table_no, bills });

    res.json({
      table_no: table_no,
      bills: bills,
    });

  } catch (err) {
    if (connection) connection.release();
    console.error(`[${new Date().toISOString()}] Error in GET /api/bill/:table_no:`, err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Bills Summary
app.get('/api/bills-summary/:table_no', async (req, res) => {
  const { table_no } = req.params;
  let connection;

  try {
    connection = await pool.getConnection();
    console.log(`Connection successful. Fetching bills summary for table ${table_no}`);

    // 1. Fetch all orders for the given table number
    const [orderRows] = await connection.query(
      `SELECT o.*, t.table_no
       FROM orders o
       JOIN tables t ON o.table_number = t.table_no
       WHERE t.table_no = ?`,
      [table_no]
    );

    console.log('orderRows:', orderRows);

    if (orderRows.length === 0) {
      connection.release();
      console.log(`No orders found for table ${table_no}`);
      return res.status(404).json({ error: 'Order not found for this table' });
    }

    // 2. Initialize array to store bills summary and grand total
    let bills = [];
    let grandTotal = 0;

    // 3. Loop through each order and calculate its total
    for (let order of orderRows) {
      // Fetch order items for this order
      const [orderItems] = await connection.query(
        `SELECT oi.id AS order_item_id, oi.menu_id, oi.menu_name, oi.option AS meat_option, oi.quantity, oi.price_each
         FROM order_items oi
         WHERE oi.order_id = ?`,
        [order.id]
      );

      console.log(`orderItems for order ${order.id}:`, orderItems);

      if (orderItems.length === 0) continue; // Skip if no items in this order

      // 4. Fetch addons and calculate total price for each item
      for (let item of orderItems) {
        const [addons] = await connection.query(
          `SELECT oia.addon_name, oia.addon_price
           FROM order_item_addons oia
           WHERE oia.order_item_id = ?`,
          [item.order_item_id]
        );

        console.log(`addons for item ${item.order_item_id}:`, addons);

        // Calculate total price for the item: (price_each * quantity) + sum(addon_price)
        const addonTotal = addons.reduce((sum, addon) => sum + Number(addon.addon_price), 0);
        item.total_price = (Number(item.price_each) * item.quantity) + addonTotal;
      }

      // 5. Calculate subtotal for this order
      const subtotal = orderItems.reduce((sum, item) => sum + item.total_price, 0);

      // 6. Calculate VAT (7%) and total for this order
      const vatRate = 0.07;
      const vat = subtotal * vatRate;
      const total = subtotal + vat;

      // 7. Add to grand total (use total directly since it already includes VAT)
      grandTotal += total;

      // 8. Add bill summary to the bills array
      bills.push({
        order_number: order.order_number,
        total: total.toFixed(2),
      });
    }

    if (bills.length === 0) {
      connection.release();
      console.log(`No items found for table ${table_no}`);
      return res.status(404).json({ error: 'No items found for this table' });
    }

    // 9. Send response with bills summary and grand total
    console.log('Returning bills summary for table:', {
      table_no,
      bills,
      grand_total: grandTotal.toFixed(2),
    });

    res.json({
      table_no: table_no,
      bills: bills,
      grand_total: grandTotal.toFixed(2),
    });

  } catch (err) {
    if (connection) connection.release();
    console.error(`[${new Date().toISOString()}] Error in GET /api/bills-summary/:table_no:`, err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ----------------------------------------------------------- Table ------------------------------------------------------------
// POST /api/tables/scan - ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÇ‡∏ï‡πä‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡πÅ‡∏Å‡∏ô QR Code
app.post('/api/tables/scan', async (req, res) => {
  try {
    let { table_no } = req.body;

    if (!table_no) {
      return res.status(400).json({ error: 'Table number is required' });
    }

    const connection = await pool.getConnection();

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏ï‡πä‡∏∞‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const [existing] = await connection.query(
      'SELECT status FROM tables WHERE table_no = ?',
      [table_no]
    );

    if (existing.length === 0) {
      connection.release();
      return res.status(404).json({ error: 'Table not found' });
    }

    if (existing[0].status === 'Occupied') {
      connection.release();
      return res.status(400).json({ error: 'Table is already occupied' });
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï status ‡πÄ‡∏õ‡πá‡∏ô "Occupied" ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï scanned_at
    const [result] = await connection.query(
      'UPDATE tables SET status = "Occupied", scanned_at = NOW() WHERE table_no = ?',
      [table_no]
    );

    connection.release();

    if (result.affectedRows === 0) {
      return res.status(500).json({ error: 'Failed to update table status' });
    }

    console.log('[%s] Table %s scanned and occupied', new Date().toISOString(), table_no);
    res.json({ message: `Table ${table_no} status updated to Occupied` });
  } catch (err) {
    console.error('Error:', err);
    console.error('[%s] Error in POST /api/tables/scan:', new Date().toISOString(), err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π
app.post('/recommend', async (req, res) => {
  try {
    const { user_input, table_id } = req.body;
    if (!user_input) {
      console.error('‚ùå Missing user_input in request body:', req.body);
      return res.status(400).json({ error: 'user_input is required' });
    }
    if (!table_id) {
      console.error('‚ùå Missing table_id in request body:', req.body);
      return res.status(400).json({ error: 'table_id is required' });
    }

    const connection = await pool.getConnection();
    try {
      const [results] = await connection.query('SELECT * FROM menu');
      if (!results || results.length === 0) {
        console.warn('‚ö†Ô∏è No menus found in database');
        return res.status(404).json({ error: 'No menus available in database' });
      }

      console.log('\nüîç Menus sent to Python service:');
      results.forEach(item => {
        console.log(`- ${item.name_eng}: tags=${item.tags}, category=${item.category}`);
      });

      const menu_data = results.map(item => ({
        id: item.id,
        name_eng: item.name_eng,
        short_description: item.short_description,
        price_starts_at: item.price_starts_at,
        combined_text: `${item.tags || ''} ${item.full_description || ''}`,
        category: item.category,
        tags: item.tags,
      }));

      console.log('üì§ Sending to FastAPI:', { user_input, table_id, menu_data_length: menu_data.length });

      const response = await axios.post('http://172.20.10.3:8000/recommend', {
        user_input,
        table_id,
        menu_data,
      });

      console.log('‚úÖ Python service response:', response.data);
      res.json(response.data);
    } catch (error) {
      console.error('‚ùå Error in recommendation endpoint:', error.message, error.response?.data);
      res.status(500).json({
        error: 'Failed to generate recommendations',
        details: error.message,
        fastapi_response: error.response?.data,
      });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('‚ùå Error in recommendation endpoint:', error.message);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
const PORT = 3000;
app.listen(3000, '0.0.0.0', () => {
  console.log("Server running on http://0.0.0.0:3000");
});